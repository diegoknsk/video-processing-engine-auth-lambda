---
alwaysApply: false
description: "Regras universais de Clean Architecture e desenvolvimento .NET — agnóstico a projeto, consolidado para excelência."
---

# Clean Architecture & Desenvolvimento .NET — Guia Universal

## Objetivo

Aplicar **Clean Architecture** de forma pragmática (~80%), mantendo separação de camadas e inversão de dependência, com foco em simplicidade, manutenibilidade e consistência. Este documento consolida regras de arquitetura e desenvolvimento .NET em um único guia reutilizável em qualquer projeto.

---

## 1. Regras Gerais de Código

### 1.1 Construtores Primários (C# 12+)

- **SEMPRE usar construtores primários** para classes que recebem dependências via DI.
- Aplicar em: UseCases, Controllers, Services, Repositories e qualquer classe com injeção de dependência.
- No .NET 10, construtores primários são totalmente otimizados pelo compilador.

```csharp
// ✅ Correto
public class CreateUserUseCase(IUserRepository userRepository, ITokenService tokenService)
{
    public async Task<CreateUserResponseModel> ExecuteAsync(CreateUserInput input, CancellationToken ct = default)
    {
        var output = await userRepository.CreateAsync(input, ct);
        return CreateUserPresenter.Present(output);
    }
}

// ❌ Evitar — construtor tradicional desnecessário
public class CreateUserUseCase
{
    private readonly IUserRepository _userRepository;
    public CreateUserUseCase(IUserRepository userRepository) => _userRepository = userRepository;
}
```

### 1.2 Collection Expressions (C# 13)

- **Preferir collection expressions** para inicialização de coleções quando disponível.

```csharp
// ✅ Correto (C# 13)
var items = [item1, item2, item3];
var combined = [..firstList, ..secondList];
var range = [1, 2, 3, ..otherNumbers];

// ❌ Evitar quando collection expressions são mais legíveis
var items = new List<Item> { item1, item2, item3 };
var combined = firstList.Concat(secondList).ToList();
```

### 1.3 Respostas HTTP e Filtros Globais

- **Todas as respostas de sucesso** devem passar por um filtro global que encapsula no formato padronizado (ex.: `ApiResponse<T>`).
- Controllers retornam diretamente os dados: `return Ok(result)`; o filtro aplica o envelope.
- **NÃO** construir manualmente `ApiResponse<T>` ou `ApiErrorResponse` nos controllers; filtro e middleware cuidam disso.
- Middleware global de exceções deve mapear exceções para respostas de erro padronizadas e códigos HTTP apropriados.
- Considerar uso de **Problem Details (RFC 7807)** para respostas de erro padronizadas no .NET 10.

### 1.4 Presenters para Adaptação de Dados

- **Adaptação de dados para o cliente** é responsabilidade de **Presenters** na camada Application.
- **UseCases chamam o Presenter** — não o Controller. Fluxo: UseCase obtém `OutputModel` → chama `Presenter.Present(output)` → retorna `ResponseModel`.
- Presenters transformam `OutputModel` em `ResponseModel` (contrato da API). Podem ser classes estáticas quando não mantêm estado.
- Estrutura sugerida: `Application/Presenters/<Contexto>/<UseCaseName>Presenter.cs`.

### 1.5 Performance e Alocações

- Para operações críticas de performance, considerar:
  - **Span<T>** e **Memory<T>** para manipulação de arrays sem alocações.
  - **ArrayPool<T>** para reutilização de buffers.
  - **ValueTask<T>** quando a operação frequentemente completa de forma síncrona.
  - **StringBuilder** para concatenação repetida de strings.
- Usar apenas quando houver necessidade comprovada (profiling); código legível tem prioridade.

```csharp
// ✅ Exemplo de uso eficiente de Span para parsing
public static int ParseNumbers(ReadOnlySpan<char> input)
{
    // Zero alocações
    return int.Parse(input);
}

// ✅ ValueTask para operações que podem ser síncronas
public ValueTask<User?> GetCachedUserAsync(string id)
{
    if (_cache.TryGetValue(id, out var user))
        return ValueTask.FromResult(user); // Sem Task alocado
    return new ValueTask<User?>(LoadUserAsync(id));
}
```

---

## 2. Estrutura de Projetos

```
<Projeto>.Api                 (ASP.NET Core — host/API)
<Projeto>.Application         (UseCases, Ports, InputModels, OutputModels, Presenters, Validators)
<Projeto>.Domain              (Entidades, Value Objects, enums, invariantes)
<Projeto>.Infra               (Implementações de Ports: APIs externas, message bus, etc.)
<Projeto>.Infra.Persistence  (Persistência — ex.: EF Core)
<Projeto>.Tests.Unit         (Testes unitários)
<Projeto>.Tests.Bdd          (Testes BDD/SpecFlow)
```

### 2.1 Regras de Dependência

```
Api → Application
Application → Domain
Infra.* → Application (implementa Ports)
Domain → Nenhuma dependência externa
```

**Domain NÃO referencia:** ASP.NET, EF Core, SDKs de cloud, HttpClient, Configuration ou qualquer framework externo. Deve ser isolado e testável sem infraestrutura.

---

## 3. Camada Application — Organização Horizontal por Contexto

Organize por **contexto** (User, Order, Payment), não por tipo de artefato:

```
Application/
  UseCases/       <Contexto>/<Verbo><Entidade>UseCase.cs
  InputModels/    <Contexto>/<UseCaseName>InputModel.cs
  OutputModels/   <Contexto>/<UseCaseName>OutputModel.cs
  Presenters/     <Contexto>/<UseCaseName>Presenter.cs
  Validators/     <Contexto>/<InputModelName>Validator.cs
  Ports/          I<ServiceName>.cs
```

**Nomenclatura:** UseCase `<Verbo><Entidade>UseCase`; InputModel/OutputModel/Presenter alinhados ao nome do UseCase; Ports `I<ServiceName>`.

---

## 4. Fluxo Request → Response

```
Controller
  → recebe InputModel via [FromBody], dados de rota e autenticação separados
  → chama UseCase.ExecuteAsync(InputModel, routeParams, authParams, CancellationToken)
UseCase
  → executa lógica de negócio, chama Ports
  → obtém OutputModel → chama Presenter.Present(OutputModel)
  → retorna ResponseModel ao Controller
Controller
  → retorna Ok(ResponseModel); filtro global formata a resposta
```

**Regras críticas:**

1. Controller **não** acessa DbContext nem infraestrutura diretamente — apenas UseCase.
2. Controller recebe **InputModel diretamente** no body — **não** criar RequestModels intermediários.
3. UseCase recebe InputModel (contrato único entre API e Application).
4. UseCase chama o Presenter e retorna ResponseModel; Controller não chama Presenter.
5. Dados de rota e autenticação vêm como parâmetros separados, não dentro do InputModel.

---

## 5. API (Controllers)

Controllers são **adapters de transporte** (HTTP).

### 5.1 Responsabilidades

- Autenticação/autorização (filtros/atributos).
- Validação básica de request (ex.: ModelState).
- Receber **InputModel** via `[FromBody]`.
- Extrair dados de rota e autenticação; chamar `UseCase.ExecuteAsync(InputModel, ...)`.
- Retornar resultado HTTP (ex.: `return Ok(result)`); filtro padroniza.

### 5.2 NÃO Criar RequestModels

- **SEMPRE** usar InputModel diretamente no body.
- **NUNCA** criar RequestModel na API nem mapeamento RequestModel → InputModel no Controller.
- InputModel é o **contrato único** entre API e Application; FluentValidation valida o InputModel.

### 5.3 Autenticação via Filtro de Ação

- Para endpoints que exigem autenticação, usar um **atributo de filtro** (ex.: `[RequireAuth]`) que:
  - Valida presença dos headers necessários (ex.: Api-Key, Api-Token).
  - Retorna 401 se ausentes.
  - Cria um contexto de autenticação (ex.: `AuthContext`) e o armazena no `HttpContext`.
- No Controller: obter o contexto via extensão (ex.: `HttpContext.GetAuthContext()`) e passar credenciais como **parâmetros separados** para o UseCase.
- **Não** incluir ApiKey/ApiToken no InputModel; **não** usar `[FromHeader]` para autenticação nos métodos — centralizar no filtro.

**Benefícios:** validação em um só lugar, controllers limpos, fácil de testar e evoluir (ex.: trocar origem das credenciais sem mudar InputModel/UseCase).

### 5.4 Padronização de Respostas e Erros

- Filtro global: encapsula respostas de sucesso em formato padrão (ex.: `ApiResponse<T>`).
- Middleware de exceções: converte exceções em `ApiErrorResponse` e mapeia tipos (ex.: `ArgumentException` → 400, `UnauthorizedAccessException` → 401, `KeyNotFoundException` → 404, exceções de API externa → código e mensagem apropriados).

### 5.5 Proibido nos Controllers

- Regras de negócio; acesso direto a banco ou SDKs; chamar Presenter; criar ApiResponse/ApiErrorResponse manualmente; lógica de transformação complexa.

---

## 6. Application Layer — Detalhes

### 6.1 UseCases

- Pequenos e focados (uma responsabilidade clara).
- Recebem **InputModel**; dados de rota e autenticação como parâmetros separados; `CancellationToken`.
- Executam lógica de negócio e chamam **Ports**; obtêm **OutputModel**; chamam **Presenter** e retornam **ResponseModel**.

**Exemplo de assinatura:**

```csharp
Task<CreateOrderResponseModel> ExecuteAsync(
    CreateOrderInput input,
    string tenantId,
    string userId,
    string apiToken,
    CancellationToken cancellationToken = default);
```

### 6.2 InputModels

- Contrato de **entrada** dos UseCases; ficam na Application.
- **Contêm apenas dados do body.** Dados de rota e headers (autenticação) **não** entram no InputModel; use parâmetros separados no UseCase.
- Se um campo for preenchido no Controller (ex.: id da rota), use `[JsonIgnore]` para não deserializar do body.
- Serialização JSON: usar camelCase padrão; `[JsonPropertyName]` apenas quando o nome na API for diferente do padrão.

### 6.3 Validação com FluentValidation

- **Validators validam apenas propriedades do InputModel** (dados do body).
- **Não** validar route params nem headers no validator — binding e filtro de autenticação cuidam disso.
- Validators **não** acessam banco nem serviços; regras de negócio ficam no UseCase/Domain.
- InputModels "vazios" (tudo vindo de rota/headers) podem ter validator vazio com comentário explicativo.
- Estrutura: `Application/Validators/<Contexto>/<InputModelName>Validator.cs`; registrar via assembly scanning e usar filtro que converte erros para o formato padrão.

### 6.4 OutputModels e Presenters

- **OutputModels:** contrato de saída interno do UseCase; ficam na Application.
- **Presenters:** transformam OutputModel → ResponseModel; chamados pelo UseCase; podem ser estáticos.

### 6.5 Ports (Interfaces)

- Definem contratos para dados e serviços externos (repositórios, tokens, APIs externas, message bus).
- Implementações na Infra.

### 6.6 Facade (Opcional)

- Use **apenas** quando um endpoint orquestrar **3+ UseCases** com lógica de orquestração relevante. Para 1–2 UseCases, chamar diretamente do Controller.

---

## 7. Domain Layer

- Entidades, Value Objects, enums, validações de domínio e exceções de domínio.
- **Nenhuma dependência externa.**
- **Não** criar entidades para tokens, credenciais ou conceitos puramente de infraestrutura; use modelos na Application/Infra.

---

## 8. Infraestrutura

- **Infra:** implementa Ports de serviços externos. Para clientes HTTP de APIs externas, **usar Refit** (interfaces tipadas, menos boilerplate, fácil de mockar).
- **Infra.Persistence:** implementa Ports de persistência; usa EF Core ou equivalente; entidades de persistência separadas das entidades de domínio; DbContext restrito a esta camada.

---

## 9. Convenções .NET e Estilo

- **Perfil:** código C# idiomático, convenções Microsoft, **.NET 10** recomendado para novos projetos.
- **Recursos C#:** record types, pattern matching, primary constructors (C# 12+), collection expressions (C# 13), null-coalescing, async/await para I/O.
- **C# 13 e .NET 10:**
  - **Collection expressions:** `[item1, item2]` em vez de `new List<T> { ... }`
  - **params Span<T>:** para métodos com parâmetros variáveis sem alocações
  - **Lock object melhorado:** `lock(obj)` com performance otimizada
  - **Async streams melhorados:** `IAsyncEnumerable<T>` para streaming de dados
- **Nomenclatura:** PascalCase (tipos, métodos, propriedades); camelCase (locais, campos privados); interfaces com prefixo `I`.
- **Erros:** exceções para casos excepcionais; logging adequado; middleware global de exceções; códigos HTTP e respostas de erro consistentes (considerar Problem Details RFC 7807).
- **DI:** injetar via construtor; não instanciar dependências fora do bootstrap; preferir interfaces; usar **keyed services** (.NET 8+) quando necessário registrar múltiplas implementações.
- **JSON:** camelCase como padrão; evitar `[JsonPropertyName]` exceto quando necessário para contrato da API; aproveitar melhorias do System.Text.Json no .NET 10.
- **Configuração sensível:** preferir variáveis de ambiente (ou IOptions) em vez de valores fixos em arquivos versionados.

---

## 10. Integração com APIs Externas (Refit)

- **Usar Refit** para clientes HTTP de APIs externas (type-safe, pouco boilerplate, fácil de testar).
- Definir interface com atributos HTTP; registrar com `AddRefitClient<T>()` e configurar BaseAddress/Timeout.
- Tratar `ApiException` (ou equivalente) nos serviços que chamam a interface e mapear para exceções/erros do domínio ou da API.
- No .NET 10, aproveitar **HTTP/3** quando suportado pelo servidor remoto para melhor performance.
- Considerar **resilience patterns** (Polly) para retry, circuit breaker e timeout.

---

## 11. Testes e Qualidade

- **Tests.Unit:** Domain, UseCases (com mocks dos Ports), Value Objects, Validators; xUnit + Moq/NSubstitute/FakeItEasy.
- **Tests.Bdd:** pelo menos um cenário BDD por serviço/feature relevante (SpecFlow ou similar).
- **Tests.Integration:** usar WebApplicationFactory para testes de integração de APIs.
- **Cobertura:** meta de cobertura de linha ≥ 80%; testes no CI/CD.
- **Mutation Testing:** considerar ferramentas como Stryker.NET para validar qualidade dos testes em projetos críticos.
- **Pré-finalização:** build sem erros, todos os testes passando, cobertura dentro da meta antes de considerar a atividade concluída (exceto quando a atividade não envolve código).

---

## 12. Observabilidade e Métricas

- **Logging estruturado:** usar ILogger com structured logging; considerar Serilog para cenários avançados.
- **Métricas:** aproveitar **System.Diagnostics.Metrics** (.NET 8+) para instrumentação nativa; exportar para Prometheus, Azure Monitor ou similar.
- **Tracing distribuído:** usar **OpenTelemetry** para rastreamento de requisições entre serviços; instrumentação automática disponível no .NET 10.
- **Health Checks:** implementar endpoints `/health` e `/health/ready` usando middleware built-in.

```csharp
// ✅ Exemplo de métrica customizada
public class OrderMetrics
{
    private readonly Counter<int> _ordersProcessed;
    
    public OrderMetrics(IMeterFactory meterFactory)
    {
        var meter = meterFactory.Create("Orders");
        _ordersProcessed = meter.CreateCounter<int>("orders.processed");
    }
    
    public void RecordOrder() => _ordersProcessed.Add(1);
}
```

---

## 13. Consistência e Benefícios

- Mesma estrutura de pastas (Application, Domain, Infra), organização por contexto, mesmo fluxo (InputModel → UseCase → OutputModel → Presenter → ResponseModel) em todos os serviços.
- Swagger/OpenAPI para documentação; respostas e erros padronizados (Problem Details quando apropriado).
- Observabilidade integrada: logging estruturado, métricas e tracing distribuído.
- Resultado: padrão mental único, boa DX, testabilidade (Domain isolado, UseCases com mocks), manutenibilidade e narrativa clara para revisões e evolução.

> *"A arquitetura é agnóstica ao tipo de hosting; a estrutura de camadas e o fluxo de dados são consistentes independentemente de onde a aplicação roda — API tradicional, Minimal API, Azure Functions, AWS Lambda ou container."*

---

## Validação por Três Perspectivas de Arquiteto

### Arquiteto 1 — Foco em Boundaries e Clean Architecture

**Aprovação:** ✅ Documento alinhado a Clean Architecture.

**Pontos fortes:**
- Regras de dependência explícitas (Api → Application → Domain; Infra implementa Ports); Domain sem dependências externas.
- InputModel como contrato único entre API e Application elimina camadas desnecessárias e mantém o boundary claro.
- Separação rota/headers vs body no InputModel e nos validators preserva responsabilidades e evita vazamento de transporte para o domínio de aplicação.

**Sugestões:**
- Considerar menção explícita a "hexagonal/ports & adapters" na introdução para quem usa essa nomenclatura.
- Opcional: reforçar que Ports são definidos pela Application e implementados pela Infra (nunca o contrário).

**Conclusão:** Adequado como guia de referência para decisões de arquitetura.

---

### Arquiteto 2 — Foco em Pragmatismo e Developer Experience

**Aprovação:** ✅ Documento utilizável no dia a dia.

**Pontos fortes:**
- Consolidação evita duplicação e referências a um projeto específico; qualquer time pode adotar.
- Regras práticas e objetivas (primary constructors, sem RequestModels, Presenter chamado pelo UseCase, Refit para APIs externas).
- Seções curtas e numeradas facilitam consulta e onboarding; exemplos de código ilustram o "como" sem amarrar a um domínio.

**Sugestões:**
- Manter sempre que possível exemplos mínimos (como os atuais) para não inflar o documento.
- Em projetos reais, considerar um "quick reference" de uma página derivado deste guia para PRs e reviews.

**Conclusão:** Recomendado para padronização entre serviços e boa DX.

---

### Arquiteto 3 — Foco em Operação, Testes e Consistência

**Aprovação:** ✅ Documento adequado para operação e qualidade.

**Pontos fortes:**
- Testes (unitários + BDD), cobertura ≥ 80% e obrigatoriedade de build/testes antes de finalizar estão explícitos.
- Filtro global de resposta e middleware de exceções padronizam comportamento entre ambientes e facilitam contrato e observabilidade.
- Estrutura de projetos e nomenclatura consistentes reduzem divergência entre times e serviços.

**Sugestões:**
- Em ambientes regulados, pode ser útil referenciar que logs e métricas devem ser tratados em cross-cutting (middleware/filters), sem detalhar aqui.
- Manter este documento como fonte única de verdade e evitar regras conflitantes em outros .mdc do mesmo repositório.

**Conclusão:** Aprovado para uso como padrão de excelência em arquitetura e desenvolvimento.
