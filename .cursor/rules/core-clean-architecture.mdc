---
alwaysApply: true
description: "Estrutura Clean Architecture (~80%) — separação de camadas, fluxo de dados, inversão de dependência e organização universal."
---

# Clean Architecture Core — Estrutura Universal

## 1. Objetivo

Aplicar **Clean Architecture** de forma pragmática (~80%): separação de camadas, inversão de dependência, foco em simplicidade e manutenibilidade. Agnóstico a projeto.

## 2. Estrutura de Projetos

```
<Projeto>.Api                 (ASP.NET Core — host/API)
<Projeto>.Application         (UseCases, Ports, InputModels, OutputModels, Presenters, Validators)
<Projeto>.Domain              (Entidades, Value Objects, enums, invariantes)
<Projeto>.Infra               (Implementações de Ports: APIs externas, message bus, etc.)
<Projeto>.Infra.Persistence   (Persistência — ex.: EF Core)
<Projeto>.Tests.Unit          (Testes unitários)
<Projeto>.Tests.Bdd           (Testes BDD/SpecFlow)
```

### Regras de Dependência

```
Api → Application
Application → Domain
Infra.* → Application (implementa Ports)
Domain → Nenhuma dependência externa
```

**Domain NÃO referencia:** ASP.NET, EF Core, SDKs de cloud, HttpClient, Configuration ou qualquer framework externo.

## 3. Application — Organização por Contexto

Organize por **contexto** (User, Order, Payment), não por tipo:

```
Application/
  UseCases/       <Contexto>/<Verbo><Entidade>UseCase.cs
  InputModels/    <Contexto>/<UseCaseName>InputModel.cs
  OutputModels/   <Contexto>/<UseCaseName>OutputModel.cs
  Presenters/     <Contexto>/<UseCaseName>Presenter.cs
  Validators/     <Contexto>/<InputModelName>Validator.cs
  Ports/          I<ServiceName>.cs
```

**Nomenclatura:** UseCase `<Verbo><Entidade>UseCase`; InputModel/OutputModel/Presenter alinhados ao nome do UseCase; Ports `I<ServiceName>`.

## 4. Fluxo Request → Response

```
Controller
  → recebe InputModel via [FromBody], dados de rota e autenticação separados
  → chama UseCase.ExecuteAsync(InputModel, routeParams, authParams, CancellationToken)
UseCase
  → executa lógica de negócio, chama Ports
  → obtém OutputModel → chama Presenter.Present(OutputModel)
  → retorna ResponseModel ao Controller
Controller
  → retorna Ok(ResponseModel); filtro global formata a resposta
```

**Regras críticas:**

1. Controller **não** acessa DbContext nem infraestrutura diretamente — apenas UseCase.
2. Controller recebe **InputModel diretamente** no body — **não** criar RequestModels intermediários.
3. UseCase recebe InputModel (contrato único entre API e Application).
4. UseCase chama o Presenter e retorna ResponseModel; Controller não chama Presenter.
5. Dados de rota e autenticação vêm como parâmetros separados, não dentro do InputModel.

## 5. API (Controllers)

### Responsabilidades

- Autenticação/autorização (filtros/atributos).
- Validação básica de request (ex.: ModelState).
- Receber **InputModel** via `[FromBody]`.
- Extrair dados de rota e autenticação; chamar `UseCase.ExecuteAsync(InputModel, ...)`.
- Retornar resultado HTTP (ex.: `return Ok(result)`); filtro padroniza.

### Não Criar RequestModels

- **SEMPRE** usar InputModel diretamente no body.
- **NUNCA** criar RequestModel na API nem mapeamento RequestModel → InputModel no Controller.
- InputModel é o **contrato único** entre API e Application.

### Autenticação via Filtro de Ação

- Usar **atributo de filtro** (ex.: `[RequireAuth]`) que:
  - Valida presença dos headers necessários (ex.: Api-Key, Api-Token).
  - Retorna 401 se ausentes.
  - Cria contexto de autenticação (ex.: `AuthContext`) e armazena no `HttpContext`.
- No Controller: obter contexto via extensão (ex.: `HttpContext.GetAuthContext()`) e passar credenciais como **parâmetros separados** para o UseCase.
- **Não** incluir ApiKey/ApiToken no InputModel; **não** usar `[FromHeader]` para autenticação nos métodos.

### Padronização de Respostas e Erros

- **Filtro global:** encapsula respostas de sucesso em formato padrão (ex.: `ApiResponse<T>`).
- **Middleware de exceções:** converte exceções em `ApiErrorResponse` e mapeia tipos (ex.: `ArgumentException` → 400, `UnauthorizedAccessException` → 401, `KeyNotFoundException` → 404).
- Considerar **Problem Details (RFC 7807)** para erros padronizados.

### Proibido nos Controllers

- Regras de negócio; acesso direto a banco ou SDKs; chamar Presenter; criar ApiResponse/ApiErrorResponse manualmente; lógica de transformação complexa.

## 6. Application Layer

### UseCases

- Pequenos e focados (uma responsabilidade).
- Recebem **InputModel**; dados de rota e autenticação como parâmetros separados; `CancellationToken`.
- Executam lógica de negócio e chamam **Ports**; obtêm **OutputModel**; chamam **Presenter** e retornam **ResponseModel**.

**Exemplo de assinatura:**

```csharp
Task<CreateOrderResponseModel> ExecuteAsync(
    CreateOrderInput input,
    string tenantId,
    string userId,
    string apiToken,
    CancellationToken cancellationToken = default);
```

### InputModels

- Contrato de **entrada** dos UseCases; ficam na Application.
- **Contêm apenas dados do body.** Dados de rota e headers (autenticação) **não** entram no InputModel; use parâmetros separados no UseCase.
- Se um campo for preenchido no Controller (ex.: id da rota), use `[JsonIgnore]` para não deserializar do body.
- Serialização JSON: camelCase padrão; `[JsonPropertyName]` apenas quando o nome na API for diferente do padrão.

### OutputModels e Presenters

- **OutputModels:** contrato de saída interno do UseCase; ficam na Application.
- **Presenters:** transformam OutputModel → ResponseModel; chamados pelo UseCase; podem ser estáticos.
- Estrutura: `Application/Presenters/<Contexto>/<UseCaseName>Presenter.cs`.

### Ports (Interfaces)

- Definem contratos para dados e serviços externos (repositórios, tokens, APIs externas, message bus).
- Implementações na Infra.

### Facade (Opcional)

- Use **apenas** quando um endpoint orquestrar **3+ UseCases** com lógica de orquestração relevante. Para 1–2 UseCases, chamar diretamente do Controller.

## 7. Domain Layer

- Entidades, Value Objects, enums, validações de domínio e exceções de domínio.
- **Nenhuma dependência externa.**
- **Não** criar entidades para tokens, credenciais ou conceitos puramente de infraestrutura; use modelos na Application/Infra.

## 8. Infraestrutura

- **Infra:** implementa Ports de serviços externos.
- **Infra.Persistence:** implementa Ports de persistência; entidades de persistência separadas das entidades de domínio; DbContext restrito a esta camada.

## 9. Respostas HTTP e Filtros Globais

- **Todas as respostas de sucesso** devem passar por filtro global que encapsula no formato padronizado (ex.: `ApiResponse<T>`).
- Controllers retornam diretamente os dados: `return Ok(result)`; o filtro aplica o envelope.
- **NÃO** construir manualmente `ApiResponse<T>` ou `ApiErrorResponse` nos controllers; filtro e middleware cuidam disso.
- Middleware global de exceções mapeia exceções para respostas de erro padronizadas e códigos HTTP apropriados.

## 10. Consistência e Benefícios

- Mesma estrutura de pastas, organização por contexto, mesmo fluxo em todos os serviços.
- Swagger/OpenAPI para documentação; respostas e erros padronizados.
- Resultado: padrão mental único, boa DX, testabilidade (Domain isolado, UseCases com mocks), manutenibilidade.

> *"A arquitetura é agnóstica ao tipo de hosting; a estrutura de camadas e o fluxo de dados são consistentes independentemente de onde a aplicação roda — API tradicional, Minimal API, Azure Functions, AWS Lambda ou container."*

---

## Quando Usar Skills Especializadas

**Regra:** Ao identificar que a tarefa envolve um dos contextos abaixo, **ler e aplicar** a skill correspondente (arquivo `SKILL.md` no caminho indicado). Não é necessário o usuário mencionar a skill — use os gatilhos para decidir.

| Se a tarefa envolver… | Skill | Caminho |
|-----------------------|-------|---------|
| Persistência, repositório, EF Core, DbContext, migrations, camada Infra.Persistence | `database-persistence` | `.cursor/skills/database-persistence/SKILL.md` |
| Port de API externa, Refit, cliente HTTP, integração com serviço externo | `external-api-refit` | `.cursor/skills/external-api-refit/SKILL.md` |
| Validators, FluentValidation, InputModels, validação de body | `validation-fluentvalidation` | `.cursor/skills/validation-fluentvalidation/SKILL.md` |
| Testes de UseCases/Domain/API, BDD, cobertura, build antes de finalizar | `testing` | `.cursor/skills/testing/SKILL.md` |
| Logging, métricas, tracing, health checks na API | `observability` | `.cursor/skills/observability/SKILL.md` |
| Otimização de repositórios ou UseCases (queries, alocações) | `performance-optimization` | `.cursor/skills/performance-optimization/SKILL.md` |
| Autenticação (filtro, JWT), autorização, secrets, proteção de endpoints | `security` | `.cursor/skills/security/SKILL.md` |
